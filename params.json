{"name":"Vult","tagline":"Vult is a transcompiler well suited to write high-performance DSP code","body":"![Vult](/other/Images/Vult.png?raw=true \"Vult\")\r\n\r\nVult is a simple and powerful language to program high-performance algorithms that may run in small microprocessors or microcontrollers. Vult is specially useful when programming  Digital Signal Processing (DSP) algorithms like audio effects or synthesizers.\r\n\r\nThe Vult compiler is actually a transcompiler which takes Vult code and produces plain C code that can be compiled in any platform with a C/C++ compiler, for example: Arduino or Teensy boards. Javascript support is coming soon. Code written in Vult has freedom.\r\n\r\nSome of the key feature of Vult are:\r\n- Fixed-Point type: The same code can be generated using using float or fixed-point arithmetic. This makes it possible to run efficiently in small processors (or super-fast in big ones).\r\n- Functions with context: Functions in Vult can have local memory and each call automatically creates a new environment. Contexts can be shared among functions.\r\n- Powerful inlining: Vult automatically inlines simple functions but can also inline complex functions if you want.\r\n\r\nThese key features enable you to write clear and simple code without sacrificing performance.\r\n\r\n**Note:** Vult is still in an alpha stage and is not recommended to use for serious projects.\r\n\r\nFuture features:\r\n- A powerful type system: Type systems make your code safer and allow making analysis to check that the code is correct. Vult will have type inference and dependent types.\r\n- More target languages: Vult will generate Javascript, C++ and Ocaml.\r\n- More language commodities: See the planed language features section.\r\n\r\n## Credits\r\n\r\nLogo design by:\r\n- John Klimt https://www.facebook.com/JohnKlimt\r\n\r\n## Using Vult\r\n\r\n### Vult Basics\r\n\r\nFunctions are declared with the keyword `fun`.\r\n\r\n```\r\nfun square(x) return x * x;\r\n```\r\nIn this case the argument the function takes an argument `x` and returns the square of the value.\r\n\r\nIntermediate results can be stored in variables with the keyword `val`.\r\n\r\n```\r\nval a = square(2);\r\nval b = square(-1);\r\n```\r\n\r\nVult has if-statements but also if-expressions.\r\n\r\n```\r\nval a = 0;\r\nif(square(-1)> 0){\r\n    a = 1;\r\n}\r\n\r\nval b = if square(-1) > 0 then -1 else 0;\r\n```\r\n\r\nThe only restriction is that if-expressions must have a `else`.\r\n\r\nVult has while-loops...\r\n\r\n```\r\nfun fact(x){\r\n    val i = x;\r\n    val acc = 1;\r\n    while(i>0){\r\n        acc = acc * i;\r\n        i = i-1;\r\n    }\r\n    return acc;\r\n}\r\n```\r\n\r\n... but often is easier to write loops as recursive functions.\r\n```\r\nfun fact(x)\r\n    if(x==0) return 1;\r\n    else return x * fact(x-1);\r\n```\r\nSo far, there's nothing special. Now lets make something more interesting.\r\n\r\n### Active Functions (functions with context)\r\n\r\nOne of the key features of Vult are the \"active functions\" which are functions that can have a persistent context. The simplest way of understanding them is by making a few examples.\r\n\r\nLets say that we want to write in Vult a function that will be called in the main loop of an Arduino program.\r\n\r\n```\r\nvoid loop(){\r\n    int x = analogRead(0);\r\n    int result = processValue(x); // something like this\r\n    analogWrite(result);\r\n}\r\n```\r\n\r\nWe want to replace the code of the function `processValue` with some Vult code that calculates, something more complex. We can start with something like this:\r\n\r\n```\r\nfun process(x) return 1/(x*x);\r\n```\r\n\r\nThe first this that we can notice is that every time the function is called the operation `1/(x*x)` is performed. In this case the operation is not that expensive, but let's assume that it is and we want to calculate it only when is necessary. In order to do that, we need to remember which was the previous value we computed; if the value is the same we return the previously calculated result, if it's different we recalculate.\r\n\r\nNow we are gonna declare two memory variables with the keyword `mem`.\r\n\r\n```\r\nfun process(x){\r\n    mem pre_x;  // we will use it to keep the previous input\r\n    mem result; // we will use it to keep the previous result\r\n\r\n    if(x != pre_x)           // if the previous input is different from the current\r\n        result = 1/(x*x);    // recompute\r\n\r\n    pre_x = x;               // updates the previous input and result\r\n\r\n    return result;\r\n}\r\n```\r\n\r\nThis function is longer than the original but only recalculates when necessary.\r\n\r\nOne important thing to have in mind is that if we call more than once the same function in a program each call has it's own context. For example:\r\n\r\n```\r\nval result_signal1 = process(signal1);\r\nval result_signal2 = process(signal2);\r\n```\r\n\r\nEach call to `process` has independent `pre_x` and `pre_result` memory places. So the values that the variable `signal1` has do no affect the results produced by `signal2`.\r\n\r\nWe can simplify the above code by declaring the function `change` as follows:\r\n\r\n```\r\n// This function returns true when the input value changes\r\nfun change(x){\r\n    mem pre_x;               // remembers the previous value\r\n    val result = pre_x != x; // checks if the value is different\r\n    pre_x = x;               // updates the previous value\r\n    return result;\r\n}\r\n```\r\n\r\nNow we can simplify our `process` function as follows:\r\n\r\n```\r\nfun process(x){\r\n    mem result; // we will use it to keep the previous result\r\n\r\n    if(change(x))            // if the previous input is different from the current\r\n        result = 1/(x*x);    // recompute\r\n\r\n    return result;\r\n}\r\n```\r\nIn a similar way we can create a set of very handy functions. For example:\r\n```\r\n// This function returns true when the input value changes from zero to anything\r\nfun edge(x){\r\n    mem pre_x;\r\n    // checks if the value is different and the previous was zero\r\n    val result = pre_x != x && pre_x == 0;\r\n    pre_x = x;\r\n    return result;\r\n}\r\n```\r\n\r\n```\r\n// This function returns true every 'n' calls\r\nfun every(n){\r\n    mem count;\r\n    val result = count == 0;\r\n    count = (count+1)%n;\r\n    return result;\r\n}\r\n```\r\n\r\nThe function every can be used as follows in order to reduce the number of times the result is recalculated.\r\n\r\n```\r\nfun process(x){\r\n    mem result; // we will use it to keep the previous result\r\n\r\n    if(every(4))           // the value is calculated every 4 calls\r\n        result = 1/(x*x);  // recompute\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n### Sharing and Reusing Contexts\r\n\r\nAs mentioned before every call to an active function creates it's own context. But what if we want to use the same context more than once?\r\n\r\nTake a look at the function `count` defined below.\r\n\r\n```\r\nfun count(){\r\n    mem counter;\r\n    counter = counter + 1;\r\n    return counter;\r\n}\r\n```\r\n\r\nWhen this function is called increments it's internal counter and returns the value. But this function is useless because every time we call it, we will have a result of `1`.\r\n\r\n```\r\nval a = count(); // a = 1\r\nval b = count(); // b = 1\r\nval c = count(); // c = 1\r\nval d = count(); // d = 1\r\nval e = count(); // e = 1\r\nval f = count(); // f = 1\r\n```\r\n\r\nIn order to reuse contexts we need to give them a name using a colon `:`. For example:\r\n\r\n```\r\nval a = x:count(); // a = 1\r\nval b = x:count(); // b = 2\r\nval c = x:count(); // c = 3\r\n\r\nval d = y:count(); // d = 1\r\nval e = y:count(); // e = 2\r\nval f = y:count(); // f = 3\r\n```\r\n\r\nIn the above code we have two contexts `x` and `y` for the calls to the `count` function. Every time we call `x:count()` we access to the same internal `counter` memory. Now that our counter is useful one thing that we may want to do is reseting the counter. In order to access the the context of a function we need to create a new function that declares the same memory variables. For example the function `reset`.\r\n\r\n```\r\nfun reset(){\r\n    mem counter;\r\n    counter = 0;\r\n}\r\n```\r\nNow we can reset the counter by using the same context.\r\n\r\n```\r\nval a = x:count(); // a = 1\r\nval b = x:count(); // b = 2\r\nval c = x:count(); // c = 3\r\n        x:reset();\r\nval d = x:count(); // d = 1\r\nval e = x:count(); // e = 2\r\n```\r\n\r\nNote: currently you can share context among functions that declare the same `mem` and sub-contexts (that have the same named function calls). A future feature is to explicitly merge types.\r\n\r\n### A Few Real Examples\r\n\r\nNow we are gonna write some real code. We are gonna write code for a digital filter. We start by writing code for a generic biquad filter http://en.wikipedia.org/wiki/Digital_biquad_filter in direct for II.\r\n\r\n```\r\nfun biquad(x,b0,b1,b2,a1,a2){\r\n    mem w1,w2;\r\n    val w0 = x -a1*w1-a2*w2;\r\n    val y0 = b0*w0 + b1*w1 + b2*w2;\r\n    w2, w1 = w1, w0;\r\n    return y0;\r\n}\r\n```\r\n\r\nThis function takes the input signal `x` and the filter coefficients. In the \"DAFX: Digital Audio Effects\" book we can find a table with all the coefficients for different filters. For example, for the low pass filter we can write:\r\n\r\n```\r\nfun lp6(x,fc) {\r\n    mem b0,b1,a1;\r\n    // we calculate the coefficients only when the 'fc' changes\r\n    if(change(fc)){\r\n        val k = tan(3.1415*fc/44100); // 44100 is the sample rate\r\n        b0 = k/(k+1);\r\n        b1 = k/(k+1);\r\n        a1 = (k-1)/(k+1);\r\n    }\r\n    return biquad(x,b0,b1,0,a1,0);\r\n}\r\n```\r\n\r\nThis function takes the cut frequency value `fc` and uses the previously defined function `change` to trigger the recalculation of the biquad coefficients only when needed.\r\n\r\nLet's say that we want to filter two signals (`signal1` and `signal2`) with our new filter and remove all frequencies above 1000 hertz.\r\n\r\n```\r\nval filtered1 = lp6(signal1,1000);\r\nval filtered2 = lp6(signal2,1000);\r\n```\r\n\r\n### Generating C Code\r\n\r\nVult is distributed as a single executable `vultc` that can be integrated with a traditional build system (make or cmake). In this example we are gonna use it directly in the command line. First copy the full code of the filter to a file and call it `filter.vult`.\r\n\r\n```\r\n/// File: filter.vult\r\n\r\nfun change(x){\r\n    mem pre_x;               // remembers the previous value\r\n    val result = pre_x != x; // checks if the value is different\r\n    pre_x = x;               // updates the previous value\r\n    return result;\r\n}\r\n\r\nfun biquad(x,b0,b1,b2,a1,a2){\r\n    mem w1,w2;\r\n    val w0 = x -a1*w1-a2*w2;\r\n    val y0 = b0*w0 + b1*w1 + b2*w2;\r\n    w2, w1 = w1, w0;\r\n    return y0;\r\n}\r\n\r\nfun lp6(x,fc) {\r\n    mem b0,b1,a1;\r\n    // we calculate the coefficients only when the 'fc' changes\r\n    if(change(fc)){\r\n        val k = tan(3.1415*fc/44100); // 44100 is the sample rate\r\n        b0 = k/(k+1);\r\n        b1 = k/(k+1);\r\n        a1 = (k-1)/(k+1);\r\n    }\r\n    return biquad(x,b0,b1,0,a1,0);\r\n}\r\n```\r\n\r\nNow you can run the Vult compiler on this file as follows:\r\n\r\n```\r\n$ vultc -ccode filter.vult -o filter\r\n```\r\n\r\nThe flag `-ccode` indicates that we want to generate C code. The flag `-o` specifies the name of the `.c` and `.h` we want to generate; in this case `filter.c` and `filter.h`.\r\n\r\nThis is the content of the `filter.h` file:\r\n\r\n```\r\n#ifndef _CODE_\r\n#define _CODE_\r\n\r\n#include <math.h>\r\n#include <stdint.h>\r\n#include \"vultin.h\"\r\n\r\n#ifdef __cplusplus\r\nextern \"C\"\r\n{\r\n#endif\r\n\r\ntypedef struct __filter_struct_0 {\r\n   float w2;\r\n   float w1;\r\n} _filter_struct_0;\r\n\r\nint _filter_struct_0_init(_filter_struct_0* st);\r\n\r\ntypedef struct __filter_struct_1 {\r\n   float pre_x;\r\n} _filter_struct_1;\r\n\r\nint _filter_struct_1_init(_filter_struct_1* st);\r\n\r\ntypedef struct __filter_struct_2 {\r\n   float b1;\r\n   float b0;\r\n   float a1;\r\n   float _i0_pre_x;\r\n   _filter_struct_0 _i1;\r\n} _filter_struct_2;\r\n\r\nint _filter_struct_2_init(_filter_struct_2* st);\r\n\r\ntypedef struct __filter_struct_0 _filter_struct_biquad;\r\n\r\nint _filter_struct_biquad_init(_filter_struct_biquad* st);\r\n\r\ntypedef struct __filter_struct_1 _filter_struct_change;\r\n\r\nint _filter_struct_change_init(_filter_struct_change* st);\r\n\r\ntypedef struct __filter_struct_2 _filter_struct_lp6;\r\n\r\nint _filter_struct_lp6_init(_filter_struct_lp6* st);\r\n\r\nfloat _filter__lp6(_filter_struct_2* _st_, float x, float fc);\r\n\r\nfloat _filter__change(_filter_struct_1* _st_, float x);\r\n\r\nfloat _filter__biquad(_filter_struct_0* _st_, float x, float b0, float b1, float b2, float a1, float a2);\r\n\r\nfloat _filter_();\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n#endif\r\n```\r\n\r\nFor each function, Vult generates a type, a type initialization and the actual function code. The naming of these types and functions follows this name convention: a function `foo` in a file `filename.vult` generates\r\n- A type `_<filename>_struct_<foo>`\r\n- A function initializer `_<filename>_struct_<foo>_init`\r\n- The function body `_<filename>_<foo>`\r\n\r\nIn order to use the generated code from a C/C++ program you need to declare a type `_<filename>_struct_<foo>` then initialize it and call your function passing a pointer to the variable. Here is an example:\r\n\r\n```\r\n#include \"filter.h\"\r\n\r\nvoid main(void){\r\n    _filter_struct_biquad my_filter;        // declare a variable (struct) 'my_filter'\r\n    _filter_struct_biquad_init(&my_filter); // initializes the structure\r\n\r\n    // Performs one step of the filter with input 0 and frequency 1000 hertz\r\n    float result = _filter_biquad(&my_filter,0,1000);\r\n}\r\n\r\n```\r\n\r\nIn order to compile the code you need include the files `vultin.c` and `vultin.h` found in the `runtime` folder.\r\n\r\nVult generates by default floating-point code. If you want to generate code to run in a microcontroller it's better to generate fixed-point code. You can read more about fixed-point arithmetic here: http://en.wikipedia.org/wiki/Fixed-point_arithmetic\r\n\r\nIn order to generate fixed-point code you need to pass the flag `-real` as follows:\r\n\r\n```\r\n$ vultc -ccode -real fixed filter.vult -o filter\r\n```\r\n\r\nThe resulting code will use 32 bit integers to represent all numeric values. This code runs much more efficiently in Arduinos or Teensy boards.\r\n\r\nIn order to convert back and forth fixed-point values, integers and floats you can use the functions included in `vultin.h` `fix_to_float`, `fix_from_float`, etc.\r\n\r\n### Planned Features\r\n- Function Specialization\r\n- Automatic Creation of Lookup Tables\r\n- VST Plugin Templates\r\n- VST with JIT Compilation\r\n- Type Inference\r\n- Type Merging\r\n- Dependent Types\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}